
R version 3.4.4 (2018-03-15) -- "Someone to Lean On"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> #mc-cross-validation.R
> # Load libraries
> suppressMessages(library(dplyr))
> # For glmnet
> suppressMessages(library(glmnet))
> suppressMessages(library(glmnetUtils))
> 
> # For survival analysis
> library(survival)
> library(survcomp)
Loading required package: prodlim
> # For MC-crossvalidations
> suppressMessages(library(rsample))
> 
> #Read arguments listed on command line
> args = (commandArgs(TRUE))
> i = as.integer(args[1]) 
> print(i)
[1] 196
> set.seed(69837693)
> 
> 
> # get clinical data -----
> coad_mccv <- readRDS("~/iClusterPlusUtils/data/mc_coad_clinical.RDS")
> vfold <- coad_mccv$splits[[i]] #choose splits
> train_id <- vfold$in_id
> patient_id <- vfold$data$patient_id
> ## Load genomic datasets
> gene = readRDS("~/iClusterPlus/coad_results/gene_coad.RDS")
> seg.cn = readRDS("~/iClusterPlus/coad_results/seg.cn_coad.RDS")
> meth450 = readRDS("~/iClusterPlus/coad_results/meth450.RDS")
> sample = readRDS("~/iClusterPlus/coad_results/sample_coad.RDS")
> sample <- sample[!duplicated(sample$patient_id), ]
> sample <- sample[sample$patient_id %in% patient_id, ]
> prot = readRDS("~/iClusterPlus/coad_results/prot.RDS")
> ## Get common sample id
> sample_id <- list( meth450$sample_id, rownames(seg.cn), sample$sample_id, prot$sample_id, gene$sample_id)
> sample_id <- Reduce(intersect, sample_id)
> ## Filter
> filter_sample_id <- function(s, m){
+   m[rownames(m) %in% s, ]
+ }
> ## Filter
> gene$matrix <- filter_sample_id(s = sample_id, m = gene$matrix)
> meth450$matrix <- filter_sample_id(s = sample_id, m = meth450$matrix)
> seg.cn <- filter_sample_id(s = sample_id, m = seg.cn)
> prot$matrix <- filter_sample_id(s = sample_id, m = prot$matrix )
> sample <- sample[sample$sample_id %in% sample_id, ]
> sample <- sample[order(sample$sample_id), ]
> require(assertthat)
Loading required package: assertthat
> assert_that(all(rownames(meth450$matrix) == rownames(seg.cn)))
[1] TRUE
> assert_that(all(rownames(gene$matrix) == rownames(seg.cn)))
[1] TRUE
> assert_that(all(rownames(prot$matrix) == rownames(seg.cn)))
[1] TRUE
> 
> ## Add patient id
> gene$matrix <- dplyr::as_data_frame(gene$matrix, rownames = "sample_id")
> meth450$matrix <- dplyr::as_data_frame(meth450$matrix, rownames = "sample_id")
> seg.cn <- dplyr::as_data_frame(seg.cn, rownames = "sample_id")
> ## join genomic head vars
> genomic <- dplyr::left_join(gene$matrix, meth450$matrix, by = "sample_id") %>% 
+   dplyr::left_join(., seg.cn, by = "sample_id")
> rm(gene)
> rm(meth450)
> rm(seg.cn)
> genomic_true_vars <- colnames(genomic %>%
+                                 dplyr::select(-"sample_id"))
> genomic_vars <- paste0("var", seq_along(1:length(genomic_true_vars)))
> colnames(genomic)[-match("sample_id", colnames(genomic))] <- genomic_vars
> # get clinical data -----
> train <- rsample::analysis(vfold)
> test <- rsample::assessment(vfold)
> ## Join genomic and clinical data
> train <- dplyr::left_join(train, sample %>% dplyr::select(patient_id, sample_id), by = "patient_id") %>% dplyr::left_join(., genomic,  by = "sample_id") %>% dplyr::select(-sample_id)
> 
> test <- dplyr::left_join(test, sample %>% dplyr::select(patient_id, sample_id), by = "patient_id") %>% dplyr::left_join(., genomic,  by = "sample_id") %>% dplyr::select(-sample_id)
> 
> nzvars <- caret::nearZeroVar(train[ ,genomic_vars])
> if (length(nzvars) > 0) {
+   train[ ,genomic_vars] <- train[ ,genomic_vars][ ,-nzvars]
+   genomic_vars <- genomic_vars[-nzvars]
+ }
> test <- test[ ,colnames(train)]
> ### Standardise covariates ----------------------
> preProcValues <- caret::preProcess(train[ ,c("age", genomic_vars) ], method = c("center", "scale") )
> trainTransformed <- as.data.frame( predict(preProcValues, train[c("age", genomic_vars) ] ) )
> colnames(trainTransformed) <- c("age", genomic_vars)
> #colnames(trainTransformed) = c("age_std")
> train <- cbind(train[ ,-match(c("age", genomic_vars), colnames(train) )], trainTransformed) %>%
+   dplyr::mutate(time = os_months,
+                 status = os_status)
> rm(trainTransformed) # but we keep preProcValues
> ## transform test set with training vars
> testTransformed <- as.data.frame( predict(preProcValues, test[ ,c("age", genomic_vars)]) )
> test <- cbind(test[ ,-match(c("age", genomic_vars), colnames(test) )], testTransformed) %>%
+   dplyr::mutate(time = os_months,
+                 status = os_status)
> # delete 
> rm(list = c("testTransformed"))
> ## Cox model
> clinical_vars <- c("stage", "log_weight", "age")
> surv_formula_clinical <- as.formula(paste0("Surv(time, status) ~ ", 
+                                            paste(clinical_vars, collapse = "+")))
> ## Create model matrix --
> x_clinical <- model.matrix(surv_formula_clinical, data = train)[, 
+                                                                 -1]  #drop the intercept
> x_clinical_test <- model.matrix(surv_formula_clinical, data = test)[, 
+                                                                     -1]  #drop the intercept
> cox.train <- coxph(surv_formula_clinical, data = train)
> # calculate risk score predictions test and train
> cox_rp = as.matrix(x_clinical_test) %*% as.vector(unlist(coef(cox.train)))
> cox_rp_train = as.matrix(x_clinical) %*% as.vector(unlist(coef(cox.train)))
> # calculate metrics
> get_survmetrics <- function(train, test = NULL, cox_rp,  cox_rp_train = NULL){
+   if(is.null(test)){
+     test <- train
+     cox_rp_train <-  cox_rp
+   }
+   ## Prepare to calculate metrics
+   ws <- rep(1, length(test$time))
+   ws[test$time > max(test$time[test$status] ) ] <- 0.01
+   
+   obs.test.time <- sort ( unique( test$time[test$status] ) )
+   #cindex
+   Cindex.cox <- survcomp::concordance.index(x = cox_rp, surv.time = test$time, surv.event = test$status, method = "conservative",  na.rm=TRUE, weights = ws)$c.index
+   
+   #brier score
+   bs.cox <- survcomp::sbrier.score2proba(data.tr = data.frame(time = train$time, event = train$status, score = cox_rp_train), data.ts = data.frame(time = test$time, event = test$status, score = cox_rp), method = c("prodlim"))
+   
+   #dindex
+   D.cox <- survcomp::D.index(x = cox_rp, surv.time = test$time, surv.event = test$status, weights = ws)
+   
+   #AUC ROC
+   AUC.cox <- survcomp::tdrocc(x = as.vector(cox_rp) , surv.time = test$time, surv.event = test$status,  time = quantile(obs.test.time, .5) )
+   
+   list("Cindex.cox" = Cindex.cox,  "bs.cox" = bs.cox, "AUC.cox" = AUC.cox, "D.cox" = D.cox) 
+ }
> 
> metrics_list <- get_survmetrics(train = train, test = test, cox_rp = cox_rp, 
+                                 cox_rp_train = cox_rp_train)
> cindex <- c(metrics_list[["Cindex.cox"]])
> bs <- c(metrics_list[["bs.cox"]]$bsc.integrated)
> auc <- c(metrics_list[["AUC.cox"]]$AUC)
> models <- c("Cox's-clinical")
> metrics_test <- data.frame(models = models, cindex = cindex, bs = bs, 
+                            auc = auc)
> ## Genomic models
> x <- train[, genomic_vars]
> x_test <- test[, genomic_vars]
> y <- train[, c("time", "status")]
> y$status <- as.integer(y$status)
> y <- as.matrix(y)
> x <- as.matrix(x)
> y_test <- test[, c("time", "status")]
> in_data <- cbind.data.frame(y, x)
> in_data_test <- cbind.data.frame(y_test, x_test)
> # expected number of non-zeros
> nz = ceiling(0.01 * length(genomic_vars))
> z = length(genomic_vars) - nz
> # register for parallelisation if available
> set.seed(82405)
> foldid <- caret::createFolds(in_data$status, k = 10, list = FALSE)
> ## do crossvalidation to find optimal alpha and lambda
> elasticnet_stuff <- cva.glmnet(x, y, family = "cox", 
+                                grouped = TRUE, foldid = foldid, parallel = FALSE>>> # calculate prognostic index
> cvm <- sapply(elasticnet_stuff$modlist, function(i) min(i$cvm))
> elasticnet <- elasticnet_stuff$modlist[[match(min(cvm), cvm)]]
> lam <- match(min(cvm), elasticnet$cvm)
> 
> # calculate risk score
> enet_rp <- as.matrix(x_test) %*% as.vector(coef(elasticnet$glmnet.fit)[, 
+                                                                        lam])
> enet_rp_train <- as.matrix(x) %*% as.vector(coef(elasticnet$glmnet.fit)[, 
+                                                                         lam])
> #-------------------
> metrics_list <- get_survmetrics(train = train, test = test, cox_rp = enet_rp, 
+                                 cox_rp_train = enet_rp_train)
> models <- c(models, "Cox's-enet-genomic")
> cindex <- c(cindex, metrics_list[["Cindex.cox"]])
> bs <- c(bs, metrics_list[["bs.cox"]]$bsc.integrated)
> auc <- c(auc, metrics_list[["AUC.cox"]]$AUC)
> metrics_test <- data.frame(models = models, cindex = cindex, bs = bs, 
+                            auc = auc)
> 
> # ## Clinico-genomic model give dummy names to vars to avoid
> # issues when creating model formula
> x_genomic <- train[, genomic_vars]
> x_genomic_test <- test[, genomic_vars]
> ## prepare input data
> x <- cbind(x_clinical, x_genomic)
> x_test <- cbind(x_clinical_test, x_genomic_test)
> y <- train[, c("time", "status")]
> y_test <- test[, c("time", "status")]
> in_data <- cbind.data.frame(y, x)
> ## Train model register for parallelisation if available
> set.seed(1347294)
> foldid <- caret::createFolds(train$status, k = 10, list = FALSE)
> pf = rep(1, ncol(x))
> pf[match(colnames(x_clinical), colnames(x))] <- 0  #clinico-genomic assumption
> # do crossvalidation to find optimal alpha and lambda
> elasticnet_stuff <- cva.glmnet(as.matrix(x), as.matrix(y), family = "cox", 
+                                grouped = TRUE, foldid = foldid, parallel = FALSE, penalty.factor = pfWWWarning messages:
1: In min(cvm, na.rm = TRUE) :
  no non-missing arguments to min; returning Inf
2: In max(lambda[idmin], na.rm = TRUE) :
  no non-mWarning messages:
1: In min(cvm, na.rm = TRUE) :
  no non-missing arguments to min; returning Inf
2: In max(lambda[idmin], na.rm = TRUE) :
  no non-missing arguments to max; returning -Inf
3: In max(lambda[idmin], na.rm = TRUE) :
  no non-missing arguments to max; returning -Inf
> ## 
> cvm <- sapply(elasticnet_stuff$modlist, function(i) min(i$cvm))
Warning message:
In min(i$cvm) : no non-missing arguments to min; returning Inf
> elasticnet <- elasticnet_stuff$modlist[[match(min(cvm), cvm)]]
> lam <- match(min(cvm), elasticnet$cvm)
> ## calculate risk score
> enet_rp_train <- as.matrix(x) %*% as.vector(coef(elasticnet$glmnet.fit)[, 
+                                                                         lam])
> enet_rp <- as.matrix(x_test) %*% as.vector(coef(elasticnet$glmnet.fit)[, 
+                                                                        lam])
> in_data_test <- cbind(y_test, x_test)
> metrics_list <- get_survmetrics(train = in_data, test = in_data_test, 
+                                 cox_rp = enet_rp,
+                                 cox_rp_train = enet_rp_train)
> #-------------------
> models <- c(models, "Cox's elastic net: clinico-genomic")
> cindex <- c(cindex, metrics_list[["Cindex.cox"]])
> bs <- c(bs, metrics_list[["bs.cox"]]$bsc.integrated)
> auc <- c(auc, metrics_list[["AUC.cox"]]$AUC)
> metrics_test <- data.frame(models = models, cindex = cindex, bs = bs, 
+                            auc = auc)
> 
> 
> saveRDS(metrics_test, paste0("~/iClusterPlusUtils/coad/results/metrics_enet", i, ".RDS") )
> 
> 
> proc.time()
    user   system  elapsed 
1641.583    1.481 1643.637 
